<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>Ø®Ø±ÙŠØ·Ø© Ø´Ø±ÙƒØ§Øª Ø§Ù„Ø¯ÙØ¹ + Ù…Ø³Ø§ÙØ§Øª + ØªØµØ¯ÙŠØ±</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    #map { height: 85vh; }
    #controls {
      padding: 10px;
      background-color: white;
    }
    button {
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="companySelect">Ø§Ø®ØªØ± Ø§Ø³Ù… Ø§Ù„Ø´Ø±ÙƒØ©:</label>
    <select id="companySelect">
      <option value="">-- Ø§Ø®ØªØ± Ø´Ø±ÙƒØ© --</option>
    </select>
    <br>
    <button id="exportBtn">ğŸ“ ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ Excel</button>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script>
    const map = L.map('map').setView([31.95, 35.93], 8);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19
    }).addTo(map);

    let allFeatures = [];
    let mainCenters = [];
    let exportData = [];

    const companySelect = document.getElementById('companySelect');
    const exportBtn = document.getElementById('exportBtn');

    fetch('https://servicespayment.github.io/servicespayment.json') // â† Ø¶Ø¹ Ø±Ø§Ø¨Ø· GitHub Ø§Ù„ØµØ­ÙŠØ­ Ù‡Ù†Ø§
      .then(response => response.json())
      .then(data => {
        allFeatures = data.features;
        mainCenters = allFeatures.slice(0, 5);

        const companyNames = [...new Set(allFeatures.map(f => f.properties.Ø´Ø±ÙƒØ©))].sort();
        companyNames.forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          companySelect.appendChild(option);
        });
      });

    function clearMapLayers() {
      map.eachLayer(layer => {
        if (layer instanceof L.Polyline || layer instanceof L.CircleMarker || layer instanceof L.GeoJSON) {
          if (!layer._url) map.removeLayer(layer);
        }
      });
    }

    function showBranchesForCompany(companyName) {
      clearMapLayers();
      exportData = [];

      const branches = allFeatures.filter(f => f.properties.Ø´Ø±ÙƒØ© === companyName);
      const centers = mainCenters.filter(f => f.properties.Ø´Ø±ÙƒØ© === companyName);

      // Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø§ÙƒØ²
      const centerLayer = L.geoJSON(centers, {
        onEachFeature: (feature, layer) => {
          const name = feature.properties.Ø§Ø³Ù…_Ø§ || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
          layer.bindPopup(`<b>Ù…Ø±ÙƒØ² Ø±Ø¦ÙŠØ³ÙŠ:</b> ${name}<br><b>Ø§Ù„Ø´Ø±ÙƒØ©:</b> ${feature.properties.Ø´Ø±ÙƒØ©}`).openPopup();
        },
        pointToLayer: (feature, latlng) => {
          return L.circleMarker(latlng, {
            radius: 8,
            color: 'green',
            fillColor: 'yellow',
            fillOpacity: 0.9
          });
        }
      }).addTo(map);

      // Ø±Ø³Ù… Ø§Ù„ÙØ±ÙˆØ¹ + Ø§Ù„Ø®Ø·ÙˆØ·
      const branchLayer = L.geoJSON(branches, {
        onEachFeature: (feature, layer) => {
          const branchName = feature.properties.Ø§Ø³Ù…_Ø§ || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
          const branchCoord = feature.geometry.coordinates;
          let nearestCenter = null;
          let minDistance = Infinity;

          // Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ù‚Ø±Ø¨ Ù…Ø±ÙƒØ² Ø±Ø¦ÙŠØ³ÙŠ Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø´Ø±ÙƒØ©
          for (let center of centers) {
            const centerCoord = center.geometry.coordinates;
            if (centerCoord[0] === branchCoord[0] && centerCoord[1] === branchCoord[1]) continue;

            const from = turf.point(centerCoord);
            const to = turf.point(branchCoord);
            const distance = turf.distance(from, to, { units: 'kilometers' });

            if (distance < minDistance) {
              minDistance = distance;
              nearestCenter = center;
            }
          }

          // Ø±Ø³Ù… Ø§Ù„Ø®Ø·
          if (nearestCenter) {
            const line = L.polyline([
              [nearestCenter.geometry.coordinates[1], nearestCenter.geometry.coordinates[0]],
              [branchCoord[1], branchCoord[0]]
            ], {
              color: 'red',
              weight: 1.5
            }).addTo(map);

            const distanceText = `${minDistance.toFixed(2)} ÙƒÙ…`;

            layer.bindPopup(
              `<b>Ø§Ù„ÙØ±Ø¹:</b> ${branchName}<br><b>Ø§Ù„Ø´Ø±ÙƒØ©:</b> ${feature.properties.Ø´Ø±ÙƒØ©}<br><b>Ø§Ù„Ù…Ø³Ø§ÙØ© Ù„Ø£Ù‚Ø±Ø¨ Ù…Ø±ÙƒØ²:</b> ${distanceText}`
            ).openPopup();

            // ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±
            exportData.push({
              "Ø§Ø³Ù… Ø§Ù„ÙØ±Ø¹": branchName,
              "Ø§Ù„Ø´Ø±ÙƒØ©": feature.properties.Ø´Ø±ÙƒØ©,
              "Ø£Ù‚Ø±Ø¨ Ù…Ø±ÙƒØ² Ø±Ø¦ÙŠØ³ÙŠ": nearestCenter.properties.Ø§Ø³Ù…_Ø§ || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ',
              "Ø§Ù„Ù…Ø³Ø§ÙØ© (ÙƒÙ…)": minDistance.toFixed(2)
            });
          }
        },
        pointToLayer: (feature, latlng) => {
          return L.circleMarker(latlng, {
            radius: 6,
            color: 'blue'
          });
        }
      }).addTo(map);

      const group = L.featureGroup([centerLayer, branchLayer]);
      map.fitBounds(group.getBounds());
    }

    companySelect.addEventListener('change', () => {
      const selected = companySelect.value;
      if (selected) {
        showBranchesForCompany(selected);
      }
    });

    // Ø²Ø± Ø§Ù„ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ Excel
    exportBtn.addEventListener('click', () => {
      if (exportData.length === 0) {
        alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±");
        return;
      }
      const worksheet = XLSX.utils.json_to_sheet(exportData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "Ø§Ù„Ù…Ø³Ø§ÙØ§Øª");
      XLSX.writeFile(workbook, "Distances.xlsx");
    });
  </script>
</body>
</html>
